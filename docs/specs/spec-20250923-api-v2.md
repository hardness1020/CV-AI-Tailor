# Tech Spec — API (Updated Authentication Implementation)

**Version:** v2.0.0
**File:** docs/specs/spec-20250923-api-v2.md
**Status:** Current
**PRD:** `prd-20250923.md`
**Contract Versions:** API v2.0 • Schema v2.0 • Queue v1.0
**Supersedes:** `spec-20250923-api.md`

## Overview & Goals

Build a robust REST API backend using Django DRF that handles comprehensive user authentication, artifact management, job description parsing, CV/cover letter generation, and document export. Target P95 ≤30s for CV generation, ≥99.5% availability, and support for 10,000 concurrent users with proper rate limiting and caching.

Links to latest PRD: `docs/prds/prd-20250923.md`

## Architecture (Detailed)

### Topology (frameworks)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      API Layer (Django DRF + JWT)                      │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────┐  │
│  │  Auth & Users   │   Artifacts     │   Generation    │   Export    │  │
│  │   ViewSets      │    ViewSets     │    ViewSets     │  ViewSets   │  │
│  │   + JWT Auth    │                 │                 │             │  │
│  └─────────────────┼─────────────────┼─────────────────┼─────────────┘  │
└──────────────────┬─┼─────────────────┼─────────────────┼─────────────────┘
                   │ │                 │                 │
                   │ │                 │                 │
┌──────────────────▼─▼─────────────────▼─────────────────▼─────────────────┐
│                    Django Business Logic Layer                          │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────┐  │
│  │  User Service   │ Artifact Service│ Matching Service│Export Service│  │
│  │  + Profile Mgmt │                 │                 │             │  │
│  └─────────────────┼─────────────────┼─────────────────┼─────────────┘  │
└──────────────────┬─┼─────────────────┼─────────────────┼─────────────────┘
                   │ │                 │                 │
       ┌───────────▼─▼─────────────────▼─────────────────▼───────────┐
       │                    Redis (Cache + Broker + JWT Blacklist)  │
       │  ┌─────────────┬─────────────┬─────────────────────────────┐ │
       │  │   Session   │    Cache    │        Celery Queues        │ │
       │  │   Store +   │    Layer    │    (artifact, generation)   │ │
       │  │ JWT Blacklist│            │                             │ │
       │  └─────────────┴─────────────┴─────────────────────────────┘ │
       └─────────────────────┬───────────────────────────────────────┘
                             │
       ┌─────────────────────▼───────────────────────────────────────┐
       │                Celery Workers                               │
       │  ┌──────────────┬──────────────┬────────────────────────┐   │
       │  │   Artifact   │   Evidence   │     Generation         │   │
       │  │  Processor   │  Validator   │      Worker            │   │
       │  └──────────────┼──────────────┼────────────────────────┘   │
       └─────────────────┼──────────────┼────────────────────────────┘
                         │              │
┌────────────────────────▼──────────────▼────────────────────────────────┐
│                    PostgreSQL Database                                 │
│  ┌─────────────┬─────────────┬─────────────┬─────────────────────────┐ │
│  │ auth_user   │ artifacts   │ evidence    │ generated_documents     │ │
│  │ (extended)  │ labels      │ links       │ export_logs             │ │
│  │ sessions    │ skills      │ validations │ job_descriptions        │ │
│  │ jwt_tokens  │             │             │ token_blacklist         │ │
│  └─────────────┴─────────────┴─────────────┴─────────────────────────┘ │
└───────────────────────────────────────────────────────────────────────┘
```

### Component Inventory

| Component | Framework/Runtime | Purpose | Interfaces (in/out) | Depends On | Scale/HA | Owner |
|-----------|------------------|---------|-------------------|------------|----------|-------|
| API Gateway | Django + Gunicorn + uv | HTTP request routing, middleware | In: HTTP/HTTPS; Out: DB, Redis, Celery | Redis, PostgreSQL | 5+ replicas behind LB | Backend |
| JWT Auth System | Django-Rest-Framework-SimpleJWT | Token-based authentication, user management | In: Auth requests; Out: JWT tokens, Redis blacklist | Redis, PostgreSQL | Stateless, auto-scale | Backend |
| Auth ViewSets | Django DRF + Custom User Model | Registration, login, logout, profile management | In: Auth requests; Out: JWT tokens, user data | Redis, PostgreSQL | Stateless, auto-scale | Backend |
| Artifact ViewSets | Django DRF | CRUD for artifacts and evidence | In: REST API calls; Out: DB queries, Celery tasks | PostgreSQL, Redis, Celery | Stateless, auto-scale | Backend |
| Generation ViewSets | Django DRF | CV/cover letter generation orchestration | In: Generation requests; Out: Celery tasks, cached results | Redis, Celery, PostgreSQL | Stateless, async processing | Backend |
| Export ViewSets | Django DRF | Document format export (PDF/Docx) | In: Export requests; Out: Binary file streams | PostgreSQL, Redis | CPU-intensive, separate scaling | Backend |
| Business Logic | Django Services | Core domain logic, validation | In: ViewSet calls; Out: Model operations | PostgreSQL, Redis | Embedded in API processes | Backend |
| JWT Token Blacklist | SimpleJWT + Redis | Secure logout and token revocation | In: Token blacklist operations; Out: Token validation status | Redis | High availability, persistent | Backend |
| Custom User Model | Django AbstractUser | Extended user profiles with preferences | In: User operations; Out: User data with profile fields | PostgreSQL | Embedded in Django processes | Backend |
| Redis Cache | Redis 7 | API response caching, session storage, JWT blacklist | In: Cache operations; Out: Cached data | - | Primary + replica, persistent | DevOps |
| Redis Broker | Redis 7 | Celery task queue management | In: Task submissions; Out: Task delivery | - | Same instance as cache | DevOps |
| Celery Workers | Celery + Python + uv | Async task processing | In: Queue messages; Out: DB updates, external API calls | Redis, PostgreSQL, LLM APIs | Auto-scale by queue depth | Backend |
| PostgreSQL | PostgreSQL 15 | Primary data persistence | In: SQL queries; Out: ACID-compliant results | - | Primary + read replicas | DevOps |

## Interfaces & Data Contracts

### Authentication Endpoints

#### User Registration
```
POST /api/v1/auth/register/
Content-Type: application/json

Request Body:
{
  "email": "user@example.com",
  "username": "username123",
  "password": "securepassword123",
  "password_confirm": "securepassword123",
  "first_name": "John",
  "last_name": "Doe"
}

Response: 201 Created
{
  "user": {
    "id": 1,
    "email": "user@example.com",
    "username": "username123",
    "first_name": "John",
    "last_name": "Doe",
    "profile_image": null,
    "phone": "",
    "linkedin_url": "",
    "github_url": "",
    "website_url": "",
    "bio": "",
    "location": "",
    "preferred_cv_template": 1,
    "email_notifications": true,
    "created_at": "2025-09-23T10:00:00Z",
    "updated_at": "2025-09-23T10:00:00Z"
  },
  "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Error Response: 400 Bad Request
{
  "email": ["A user with this email already exists."],
  "password": ["This password is too short. It must contain at least 8 characters."],
  "password_confirm": ["Passwords don't match."]
}
```

#### User Login
```
POST /api/v1/auth/login/
Content-Type: application/json

Request Body:
{
  "email": "user@example.com",
  "password": "securepassword123"
}

Response: 200 OK
{
  "user": {
    "id": 1,
    "email": "user@example.com",
    "username": "username123",
    "first_name": "John",
    "last_name": "Doe",
    "profile_image": null,
    "phone": "",
    "linkedin_url": "",
    "github_url": "",
    "website_url": "",
    "bio": "",
    "location": "",
    "preferred_cv_template": 1,
    "email_notifications": true,
    "created_at": "2025-09-23T10:00:00Z",
    "updated_at": "2025-09-23T10:00:00Z"
  },
  "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Error Response: 400 Bad Request
{
  "error": "Invalid credentials"
}
```

#### Token Refresh
```
POST /api/v1/auth/token/refresh/
Content-Type: application/json

Request Body:
{
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Response: 200 OK
{
  "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Error Response: 401 Unauthorized
{
  "detail": "Token is invalid or expired",
  "code": "token_not_valid"
}
```

#### User Logout
```
POST /api/v1/auth/logout/
Authorization: Bearer <access_token>
Content-Type: application/json

Request Body:
{
  "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Response: 200 OK
{
  "message": "Successfully logged out"
}

Error Response: 400 Bad Request
{
  "error": "Invalid token"
}
```

#### User Profile Management
```
GET /api/v1/auth/profile/
Authorization: Bearer <access_token>

Response: 200 OK
{
  "id": 1,
  "email": "user@example.com",
  "username": "username123",
  "first_name": "John",
  "last_name": "Doe",
  "profile_image": null,
  "phone": "+1234567890",
  "linkedin_url": "https://linkedin.com/in/johndoe",
  "github_url": "https://github.com/johndoe",
  "website_url": "https://johndoe.com",
  "bio": "Software Engineer with 5 years experience",
  "location": "San Francisco, CA",
  "preferred_cv_template": 2,
  "email_notifications": true,
  "created_at": "2025-09-23T10:00:00Z",
  "updated_at": "2025-09-23T10:00:00Z"
}

PATCH /api/v1/auth/profile/
Authorization: Bearer <access_token>
Content-Type: application/json

Request Body:
{
  "first_name": "Jane",
  "bio": "Updated bio",
  "location": "New York, NY"
}

Response: 200 OK
{
  // Updated user profile object
}
```

#### Password Management
```
POST /api/v1/auth/change-password/
Authorization: Bearer <access_token>
Content-Type: application/json

Request Body:
{
  "current_password": "oldpassword123",
  "new_password": "newpassword123",
  "new_password_confirm": "newpassword123"
}

Response: 200 OK
{
  "message": "Password changed successfully"
}

Error Response: 400 Bad Request
{
  "error": "Current password is incorrect"
}

POST /api/v1/auth/password-reset/
Content-Type: application/json

Request Body:
{
  "email": "user@example.com"
}

Response: 200 OK
{
  "message": "If this email exists, a password reset link has been sent"
}
```

### Artifact Management Endpoints
```
POST /api/v1/artifacts
Headers: Authorization: Bearer <token>
Body: {
  title: string,
  description: string,
  start_date: date,
  end_date: date?,
  technologies: string[],
  collaborators: string[],
  evidence_links: [{url: string, type: enum, description: string}]
}
Response: 202 {artifact_id, status: "processing", task_id}

GET /api/v1/artifacts
Headers: Authorization: Bearer <token>
Query: ?page=1&limit=20&label=<label_id>&tech=<tech_name>
Response: 200 {
  artifacts: [{
    id, title, description, start_date, end_date,
    technologies, labels, evidence_links, validation_status
  }],
  pagination: {page, limit, total, has_next}
}

PUT /api/v1/artifacts/{id}
PATCH /api/v1/artifacts/{id}
DELETE /api/v1/artifacts/{id}
```

### Label and Skill Management
```
POST /api/v1/labels
Body: {name: string, description: string, role_type: enum, artifact_ids: int[]}
Response: 201 {label_id, name, artifact_count}

GET /api/v1/labels
Response: 200 {labels: [{id, name, description, role_type, artifact_count}]}

GET /api/v1/skills/suggest
Query: ?query=<partial_skill_name>
Response: 200 {suggestions: [{name, category, frequency}]}
```

### Generation Endpoints
```
POST /api/v1/generate/cv
Body: {
  job_description: string,
  company_name: string,
  role_title: string,
  label_ids: int[],
  template_id: int?,
  custom_sections: object?
}
Response: 202 {generation_id, status: "processing", estimated_completion}

GET /api/v1/generate/cv/{id}
Response: 200 {
  id, status: enum, content: object, evidence_links: object[],
  created_at, completed_at, job_description_hash
}

POST /api/v1/generate/cover-letter
Body: {
  job_description: string,
  company_name: string,
  role_title: string,
  artifact_ids: int[],
  tone: enum
}
Response: 202 {generation_id, status: "processing"}
```

### Export Endpoints
```
POST /api/v1/export/{generation_id}
Body: {format: enum["pdf", "docx"], include_evidence: boolean, qr_codes: boolean}
Response: 202 {export_id, status: "processing"}

GET /api/v1/export/{export_id}
Response: 200 {
  Content-Type: application/pdf | application/vnd.openxmlformats-officedocument.wordprocessingml.document,
  Content-Disposition: attachment; filename="cv_generated.pdf"
}
```

### Error Response Format
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid request data",
    "details": {
      "field_errors": {
        "email": ["This field is required"],
        "evidence_links": ["URL validation failed for: https://invalid-url"]
      }
    },
    "request_id": "req_123456789"
  }
}
```

## Data & Storage

### Database Schema Updates

#### Enhanced User Model
```sql
-- Updated auth_user table with extended fields
ALTER TABLE auth_user ADD COLUMN profile_image VARCHAR(100);
ALTER TABLE auth_user ADD COLUMN phone VARCHAR(20) DEFAULT '';
ALTER TABLE auth_user ADD COLUMN linkedin_url VARCHAR(200) DEFAULT '';
ALTER TABLE auth_user ADD COLUMN github_url VARCHAR(200) DEFAULT '';
ALTER TABLE auth_user ADD COLUMN website_url VARCHAR(200) DEFAULT '';
ALTER TABLE auth_user ADD COLUMN bio TEXT DEFAULT '';
ALTER TABLE auth_user ADD COLUMN location VARCHAR(100) DEFAULT '';
ALTER TABLE auth_user ADD COLUMN preferred_cv_template INTEGER DEFAULT 1;
ALTER TABLE auth_user ADD COLUMN email_notifications BOOLEAN DEFAULT TRUE;
ALTER TABLE auth_user ADD COLUMN created_at TIMESTAMP DEFAULT NOW();
ALTER TABLE auth_user ADD COLUMN updated_at TIMESTAMP DEFAULT NOW();

-- JWT Token Blacklist
CREATE TABLE token_blacklist_outstandingtoken (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,
    jti VARCHAR(255) UNIQUE NOT NULL,
    token TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL
);

CREATE TABLE token_blacklist_blacklistedtoken (
    id SERIAL PRIMARY KEY,
    token_id INTEGER REFERENCES token_blacklist_outstandingtoken(id) ON DELETE CASCADE,
    blacklisted_at TIMESTAMP DEFAULT NOW()
);

-- Performance indexes for authentication
CREATE INDEX idx_user_email_active ON auth_user(email, is_active);
CREATE INDEX idx_outstanding_token_jti ON token_blacklist_outstandingtoken(jti);
CREATE INDEX idx_outstanding_token_user ON token_blacklist_outstandingtoken(user_id, expires_at);
CREATE INDEX idx_blacklisted_token_lookup ON token_blacklist_blacklistedtoken(token_id);
```

#### Existing Schema (preserved)
```sql
-- Artifacts and Evidence (unchanged)
CREATE TABLE artifacts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    start_date DATE,
    end_date DATE,
    technologies TEXT[] DEFAULT '{}',
    collaborators TEXT[] DEFAULT '{}',
    metadata JSONB DEFAULT '{}',
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- [Other tables remain unchanged]
```

### Authentication Security Configuration

#### JWT Settings
```python
# JWT Configuration
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': settings.SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'TOKEN_TYPE_CLAIM': 'token_type',
}

# Authentication Classes
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}
```

#### Password Validation
```python
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 8,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
```

## Security & Privacy Enhancements

### JWT Token Security
```python
# Token Blacklist Implementation
from rest_framework_simplejwt.tokens import RefreshToken

class SecureLogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            refresh_token = request.data["refresh"]
            token = RefreshToken(refresh_token)
            token.blacklist()  # Add to blacklist
            return Response({"message": "Successfully logged out"})
        except Exception as e:
            return Response({"error": "Invalid token"},
                          status=status.HTTP_400_BAD_REQUEST)

# Automatic token cleanup
@periodic_task(run_every=crontab(hour=2, minute=0))
def cleanup_expired_tokens():
    """Remove expired tokens from blacklist"""
    OutstandingToken.objects.filter(
        expires_at__lt=timezone.now()
    ).delete()
```

### Enhanced User Model Security
```python
class CustomUser(AbstractUser):
    """Extended user model with security enhancements"""

    email = models.EmailField(unique=True)

    # Profile fields
    profile_image = models.ImageField(upload_to='profiles/', blank=True, null=True)
    phone = models.CharField(max_length=20, blank=True)
    linkedin_url = models.URLField(blank=True)
    github_url = models.URLField(blank=True)
    website_url = models.URLField(blank=True)
    bio = models.TextField(blank=True)
    location = models.CharField(max_length=100, blank=True)

    # Settings
    preferred_cv_template = models.IntegerField(default=1)
    email_notifications = models.BooleanField(default=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']

    def clean(self):
        super().clean()
        self.email = self.__class__.objects.normalize_email(self.email)
```

## Reliability & SLIs/SLOs (Updated)

### Service Level Indicators
- **Authentication Availability:** Percentage of successful auth endpoint responses (non-5xx)
- **Token Validation Latency:** P50, P95, P99 for JWT token validation
- **Registration Success Rate:** Percentage of successful user registrations
- **Login Success Rate:** Percentage of successful user logins (excluding invalid credentials)

### Service Level Objectives
- **Authentication Availability:** ≥99.9% for auth endpoints (login, register, token refresh)
- **Authentication Latency Targets:**
  - User registration: P95 ≤1s
  - User login: P95 ≤500ms
  - Token refresh: P95 ≤200ms
  - Profile operations: P95 ≤300ms
- **Token Security:** 100% token blacklist effectiveness for logged out sessions
- **Data Consistency:** ≥99.9% user profile integrity

### Reliability Mechanisms
```python
# Authentication Rate Limiting
from django_ratelimit import ratelimit

@ratelimit(key='ip', rate='5/m', method='POST', block=True)
def login_view(request):
    """Rate limit login attempts by IP"""
    pass

@ratelimit(key='ip', rate='3/m', method='POST', block=True)
def register_view(request):
    """Rate limit registration attempts by IP"""
    pass

# Circuit Breaker for Token Validation
@CircuitBreaker(failure_threshold=10, timeout=30)
def validate_blacklisted_token(token_jti):
    """Check if token is blacklisted with circuit breaker"""
    return BlacklistedToken.objects.filter(
        token__jti=token_jti
    ).exists()
```

## Evaluation Plan

### Authentication Testing Strategy
```python
# Authentication Integration Tests
class AuthenticationFlowTest(APITestCase):

    def test_complete_auth_flow(self):
        """Test registration -> login -> profile access -> logout"""
        # Register user
        register_data = {
            "email": "test@example.com",
            "username": "testuser",
            "password": "testpass123",
            "password_confirm": "testpass123",
            "first_name": "Test",
            "last_name": "User"
        }
        register_response = self.client.post('/api/v1/auth/register/', register_data)
        self.assertEqual(register_response.status_code, 201)

        # Extract tokens
        access_token = register_response.data['access']
        refresh_token = register_response.data['refresh']

        # Access protected resource
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {access_token}')
        profile_response = self.client.get('/api/v1/auth/profile/')
        self.assertEqual(profile_response.status_code, 200)

        # Logout and verify token blacklist
        logout_response = self.client.post('/api/v1/auth/logout/',
                                         {'refresh': refresh_token})
        self.assertEqual(logout_response.status_code, 200)

        # Verify token is blacklisted
        refresh_response = self.client.post('/api/v1/auth/token/refresh/',
                                          {'refresh': refresh_token})
        self.assertEqual(refresh_response.status_code, 401)

# Load Testing for Authentication
class AuthLoadTest(HttpUser):
    wait_time = between(1, 3)

    @task
    def register_and_login(self):
        # Register new user
        user_data = {
            "email": f"user{random.randint(1000,9999)}@example.com",
            "username": f"user{random.randint(1000,9999)}",
            "password": "testpass123",
            "password_confirm": "testpass123",
            "first_name": "Load",
            "last_name": "Test"
        }

        register_response = self.client.post("/api/v1/auth/register/",
                                           json=user_data)

        if register_response.status_code == 201:
            # Login with same credentials
            login_response = self.client.post("/api/v1/auth/login/",
                                            json={
                                                "email": user_data["email"],
                                                "password": user_data["password"]
                                            })

            if login_response.status_code == 200:
                # Access profile
                token = login_response.json()["access"]
                self.client.get("/api/v1/auth/profile/",
                              headers={"Authorization": f"Bearer {token}"})
```

## Changes from Previous Version

### Contract Changes (Breaking)
1. **Registration Endpoint:** Added required `username` field
2. **Response Format:** Changed from nested `tokens` object to flat `access` and `refresh` fields
3. **User Model:** Added extensive profile fields (phone, social URLs, bio, location, preferences)
4. **Authentication:** Implemented JWT token blacklisting for secure logout
5. **Password Management:** Added password change and reset endpoints

### New Features
1. **Comprehensive User Profiles:** Support for social links, bio, location, and preferences
2. **Secure Logout:** JWT token blacklisting prevents token reuse after logout
3. **Password Management:** Change password and reset functionality
4. **Enhanced Error Handling:** Detailed validation error responses
5. **Profile Management:** Update user profile information independently

### Security Improvements
1. **JWT Token Rotation:** Refresh tokens are rotated on each use
2. **Token Blacklisting:** Logout invalidates tokens permanently
3. **Rate Limiting:** Protection against brute force attacks
4. **Password Validation:** Django's built-in password validators
5. **Email Uniqueness:** Enforced at database level

## Rollout & Ops Impact

### Migration Strategy
```python
# Migration for authentication system
class Migration(migrations.Migration):
    dependencies = [('accounts', '0001_initial')]

    operations = [
        # Add new user fields
        migrations.AddField('User', 'profile_image',
                          models.ImageField(upload_to='profiles/', blank=True, null=True)),
        migrations.AddField('User', 'phone',
                          models.CharField(max_length=20, blank=True)),
        # ... other profile fields

        # Create JWT blacklist tables
        migrations.RunSQL("""
            CREATE TABLE token_blacklist_outstandingtoken (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES auth_user(id),
                jti VARCHAR(255) UNIQUE NOT NULL,
                token TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP NOT NULL
            );
        """),
    ]
```

### Monitoring Enhancements
```python
# Authentication-specific metrics
auth_requests_total = Counter(
    'auth_requests_total',
    'Total authentication requests',
    ['endpoint', 'status', 'user_agent']
)

token_validations_total = Counter(
    'token_validations_total',
    'Total token validations',
    ['result']  # valid, invalid, blacklisted, expired
)

auth_duration = Histogram(
    'auth_duration_seconds',
    'Authentication operation duration',
    ['operation']  # login, register, logout, refresh
)
```

## Open Questions

1. **Profile Image Storage:** Local file storage vs cloud storage (S3) for profile images
2. **Social Authentication:** Integration with OAuth providers (Google, GitHub, LinkedIn)
3. **Multi-Factor Authentication:** TOTP or SMS-based 2FA implementation
4. **Account Verification:** Email verification for new registrations
5. **Password Reset Security:** Token-based vs email link-based password reset

## Changelog

- 2025-09-23: v2.0.0 - Updated authentication contracts to match implementation; added comprehensive user profiles; implemented JWT token blacklisting; added password management endpoints; enhanced security and error handling
- 2025-09-23: v1.0.0 - Initial API specification (superseded)